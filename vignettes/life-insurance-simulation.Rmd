---
title: "Life Insurance Simulation"
author: "Andy Merlino"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

We provide life insurance.  

How much money do we need to set aside today so we will have enough money to cover the entire life insurance benefit for all of our policies?  

Note: The `insuree` package refers to each individual person's policy as an "insuree".

```{r load_stuff}
library(insuree)
library(knitr) # for tables

options(scipen=999) # turn off scientific notation
```

Let's create some life insurance policies.

```{r create_policies, results = "asis"}
policies <- data.frame(id = c("A001", "A002", "A003", "A004", "A005", "A006"),
                       gender = c("male", "female", "female", "male", "male", "female"),
                       age = c(40, 51, 70, 45, 65, 35),
                       death_benefit = c(200000, 500000, 100000, 500000, 1000000, 2000000))

# format and print table
out <- policies
out$death_benefit <- format(out$death_benefit, big.mark = ",")
knitr::kable(out, align = c("l", "l", "r", "r"))
```

Each row in the above table represents an individual insuree.  If all of these individuals die this very second our liability will be `r format(sum(policies$death_benefit), big.mark = ",")`.  The probability of these `r nrow(policies)` people dying instantaneously is low, and since we can invest and grow our money over time we don't need to keep `r format(sum(policies$death_benefit), big.mark = ",")` in reserve to have a high probability of fullfilling our liabilities.  The `insuee` package can simulate the time until death for the individuals and thus come up with probabilities for how much money (calculated at present value) we (as the insurer) are actually on the hook for.

Back to the policies: As you can see, we have male and female insurees of varying ages.  They also have varying death benefits.

We are going to create an object of class `insuree::Insuree` to represent each one of our insurees.  The future probability of death for each of these `insuree::Insuree` objects is defined by an actuarial life table.  The `insuree` package can use any life table you want, but here we are using the official 2010 US social security life table as provided on the [Official Social Security Website](http://www.ssa.gov/oact/STATS/table4c6.html).

Before the life tables can be used we need to define them as `LifeTable` objects:

```{r life_tables}
# create male life table from qx_data (provided with the package)
qx_male <- insuree::LifeTable(x = c(qx_data$x, max(qx_data$x) + 1), 
                              q_x = c(qx_data$male_qx, NA)
                              )

# create female life table from qx_data (provided with the package)
qx_female <- insuree::LifeTable(x = c(qx_data$x, max(qx_data$x) + 1),
                                q_x = c(qx_data$female_qx, NA)
                                )
```

Now that we have male and female life tables lets assign each insuree to an `insuree::Insuree` object.  The `Insuree` object identifies the `LifeTable`, age, and
other policy characteristics appropriate to the individul policy.  Once the `Insuree` object is defined we can run the simulations.

```{r}
# I am finding the max age of the life tables so I can 
# make examples inwhich the Insuree's life insurance policy 
# lasts until the end of the life table.
max_m <- max(qx_male@x)
max_f <- max(qx_female@x)

# define each policy as an Insuree object
hold <- list()
for (j in 1:nrow(policies)) {
  hold[[j]] <- if (policies$gender[j] == "male") {
    insuree::Insuree(x_ = policies$age[j], 
                     t_ = max_m - policies$age[j],
                     benefit_t = max_m - policies$age[j],
                     benefit_value = policies$death_benefit[j],
                     qx_male)
  } else {
    insuree::Insuree(x_ = policies$age[j],
                     t_ = max_f - policies$age[j],
                     benefit_t = max_f - policies$age[j], 
                     benefit_value = policies$death_benefit[j],
                     qx_female)
  }
}
```

Each element in our `hold` object is an object of class `Insuree`.  We can simulate the future life and present value of the benefits for any of these `Insuree` objects individually like so

```{r}
# select number of times to simulate the individual's future life
n <- 100000

# set discount rate
rate <- 0.04
```

To run the simulation and discount to present value we need to decide how many simulations we want to run and our discount rate.

```{r, results = "asis"}
set.seed(12345)
quants <- c(seq(0.70, 0.95, by = 0.05), 0.99, 0.999, 0.9999)
# simulate individual Insuree
single <- rpv(hold[[1]], n = n, interest = rate)
total <- single$pv
quantiles <- quantile(total, quants)
sim_mean <- mean(total)

# make it look decent for printing
out <- data.frame("Risk Level" = c("mean", names(quantiles)),
                 "Value" = format(round(c(sim_mean, quantiles), 0), big.mark = ","))
knitr::kable(out, row.names = FALSE, align = c("l", "r"))
```

The above table shows our simulations of the first row/insuree in our table of policies.  The "Value" column in the above table shows our risk/confidence level for the present value of the death benefit payment.  The above table should appear reasonable for a `r policies$age[1]` year old American `r policies$gender[1]` with a `r format(policies$death_benefit[1], big.mark = ",")` life insurance policy.

The package also comes with some built in plot options for `rpv()` on class `Insuree`.

```{r, fig.width = 7, message = FALSE}
plot(single)
hist(single)
```

Simulating one life insurance policy is not that interesting.  The real power of the `insuree` package come when we group the policies together.  By simulating the group we can come up with confidence levels for the present value of future benefit payments that would otherwise be very difficult to calculate.

We run `r format(n, big.mark = ",")` observations of each individual's future life expectancy.  We assume each individual future life expectancy is independent.  We discount the death benefit, assuming a `r rate * 100`% annual interest rate.

```{r, result = "asis"}
# create object of class "Pool"
pool <- Pool(insurees = hold)
# run simulation on each insuree
# we are only interested in the present value of the simulation here
pooled_rpv <- insuree::rpv(pool, n = n, interest = rate)
total <- apply(summary(pooled_rpv), 1, sum)
quantiles <- quantile(total, c(seq(0.70, 0.95, by = 0.05), 0.99, 0.999, 0.9999))
sim_mean <- mean(total)

# make it look decent for printing
out <- data.frame("Risk Level" = c("mean", names(quantiles)),
                 "Value" = format(c(sim_mean, quantiles), big.mark = ","))
knitr::kable(out, row.names = FALSE, align = c("l", "r"))
```

and we can make similar plots to those for the single `Insuree` object:

```{r, fig.width = 7, message = FALSE}
plot(pooled_rpv)
hist(pooled_rpv)
```